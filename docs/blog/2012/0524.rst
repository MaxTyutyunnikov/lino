20120524
========

Defining row actions
--------------------


Ich hatte gestern "aus Versehen" begonnen, 
am neuen Feature "Workflows" zu arbeiten. 

Das (hoffentlich) einzig Schwierige daran ist jetzt geschafft:
dass man Aktionen einfacher definieren kann in Form 
von Klassenmethoden mit dem Dekorator `@action`.

Knapp 8 Stunden hat die Operation gedauert. 
War etwas schwieriger als ich geahnt hatte.
Lino ist jetzt wieder "auf den Beinen, aber noch etwas geschwächt":
die meisten Sachen funktionieren wieder, 
aber wahrscheinlich sind noch ein paar Bugs auszubügeln. 

:checkin:`631cc40f83eb`.

Diese Änderung hatte ich mir schon seit Längerem gewünscht, 
denn das bisherige System war wirklich nicht schön.
Ich hatte es zurückgestellt, weil es keinen konkreten Bedarf gab.
Aber die Workflows wären nicht sehr überzeugend ohne diese Änderung.

Angesichts der Buggefahr und der Tatsache, dass das jetzt eigentlich 
nicht so dringend war, war das nochmal wieder einer jener 
"Nebensprünge aufgrund spontaner Eingebungen", 
die in einem größeren Team unmöglich wären, 
aber die ich mir als Einzelprogrammierer glücklicherweise 
erlauben darf.

Jedenfalls bin ich begeistert, wie schön Lino dadurch 
geworden ist (an dieser Stelle, die bisher noch nicht schön war).
Bisher musste man einfache Aktionen wie folgt definieren::

    class UnregisterCandidate(dd.RowAction):
        label = _("Unregister")
        url_action_name = "unregister"
        def run(self,ar,elem):
            course = elem.course
            elem.course = None
            elem.save()
            return ar.ui.success_response(refresh_all=True,
              message=_("%(person)s has been unregistered from %(course)s") 
                % dict(person=elem.person,course=course))

    class ParticipantsByCourse(RequestsByCourse):
        ...
        @classmethod
        def setup_actions(self):
            self.add_action(UnregisterCandidate())


Jetzt schreibt man einfach::

    @dd.action(_("Unregister"))
    def unregister(self,ar,elem):
        course = elem.course
        elem.course = None
        elem.save()
        return ar.ui.success_response(refresh_all=True,
          message=_("%(person)s has been unregistered from %(course)s") 
            % dict(person=elem.person,course=course))



CBSS connection
---------------


-------------------- 20120524
Traceback (most recent call last):
  File "/usr/local/django/test_dsbe/using/lino/lino/modlib/cbss/models.py", line 237, in execute_request
    retval = self.execute_request_(now,simulate_response)
  File "/usr/local/django/test_dsbe/using/lino/lino/modlib/cbss/models.py", line 344, in execute_request_
    srvreq = self.build_request()
  File "/usr/local/django/test_dsbe/using/lino/lino/modlib/cbss/models.py", line 849, in build_request
    if not self.birth_date.is_complete():
AttributeError: 'str' object has no attribute 'is_complete'

-------------------- 20120524
E
======================================================================
ERROR: test_them_all (lino.modlib.cbss.tests.cbss_tests.QuickTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/usr/local/django/test_dsbe/using/lino/lino/utils/test.py", line 124, in test_them_all
    v(self)
  File "/usr/local/django/test_dsbe/using/lino/lino/modlib/cbss/tests/cbss_tests.py", line 264, in test01
    ar = cbss.IdentifyPersonResult.request(master_instance=req)
  File "/usr/local/django/test_dsbe/using/lino/lino/utils/tables.py", line 853, in request
    return TableRequest(ui,self,request,action,**kw)
  File "/usr/local/django/test_dsbe/using/lino/lino/utils/tables.py", line 162, in __init__
    self.data_iterator = self.get_data_iterator()
  File "/usr/local/django/test_dsbe/using/lino/lino/utils/tables.py", line 382, in get_data_iterator
    for row in rows:
TypeError: 'NoneType' object is not iterable

----------------------------------------------------------------------
Ran 1 test in 12.329s