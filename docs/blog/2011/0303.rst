20110303
========

Vorbereitungen Demo in Pärnu
----------------------------


6.20 Uhr. Cool: Babel-Felder werden jetzt automatisch expandiert. 
Also (zumindest deswegen) sind keine lokalen .dtl-Dateien mehr nötig.

8 Uhr. Release :doc:`/releases/20110303` and upgrade in Pärnu.

Upgrade nach 1.0.6 in Eupen
---------------------------

10 Uhr. Ich nutze den Altweiberdonnerstag aus, um auch in Eupen 
den Lino auf 1.0.6 zu heben. 

Abgesehen von den erwarteten 
Anpassungen im .dpy-Dump hatte ich 
auch folgende Überraschung::

  Problem installing fixture '/usr/local/django/dsbe_eupen/fixtures/d20110303u.dpy': Traceback (most recent call last):
    File "/var/snapshots/django/django/core/management/commands/loaddata.py", line 174, in handle
      obj.save(using=using)
    File "/var/snapshots/lino/lino/utils/dpy.py", line 246, in save
      if not self.try_save(obj,*args,**kw):
    File "/var/snapshots/lino/lino/utils/dpy.py", line 292, in try_save
      dblogger.debug("Deferred %s : %s",obj2str(obj),e)
    File "/var/snapshots/lino/lino/tools.py", line 95, in obj2str
      return u"%s #%s (%s)" % (i.__class__.__name__,i.pk,i)
    File "/var/snapshots/lino/lino/modlib/properties/models.py", line 246, in __unicode__
      self.group,self.property,
    File "/var/snapshots/django/django/db/models/fields/related.py", line 304, in __get__
      rel_obj = QuerySet(self.field.rel.to).using(db).get(**params)
    File "/var/snapshots/django/django/db/models/query.py", line 349, in get
      % self.model._meta.object_name)
  DoesNotExist: PropGroup matching query does not exist.
  
Also `lino.tools.obj2str` ist jetzt ein bisschen narrensicherer.

Und hier noch eine Überraschung. 
Wenn beim :term:`loaddata` irgendwas nicht klappt, dann macht
:term:`initdb` ja eine Warnung im Stil::

  WARNING Abandoning with 49 unsaved instances.
  Problem installing fixture '/usr/local/django/dsbe_eupen/fixtures/d20110303u.dpy': Traceback (most recent call last):
    File "/var/snapshots/django/django/core/management/commands/loaddata.py", line 174, in handle
      obj.save(using=using)
    File "/var/snapshots/lino/lino/utils/dpy.py", line 260, in save
      raise Exception("Abandoned with %d unsaved instances. See dblog for details." % len(save_later))
  Exception: Abandoned with 49 unsaved instances. See dblog for details.

Also man muss die :xfile:`system.log` konsultieren um zu sehen, 
welches denn diese 49 Records waren. 
Dumm ist dann nur, wenn in der lokalen :setting:`LOGGING` 
etwas anderes als ``level='DEBUG'`` stand. 
Dann sieht man nämlich die Debug-Meldungen nicht.

Zunächst habe ich daraufhin über eine halbe Stunde gewurstelt, 
damit :term:`initdb` folgenden Test macht, 
um mich vor meiner eigenen Dummheit zu schützen::

    if not dblogger.logger.isEnabledFor(logging.DEBUG):
        raise CommandError("System logger must be enabled for DEBUG")
        
Man kann dort nicht einfach nur auf `dblogger.logger.level` schauen, 
weil die praktisch immer 0 (``UNSET``) ist. Und es hat auch keinen Zweck, 
mit `dblogger.logger.setLevel` den level dort zu heben, weil ja schon 
der root logger die Meldungen rausfängt.

Danach fiel mir noch ein, dass es eigentlich logischer ist,
außerdem in :class:`lino.utils.dpy.FakeDeserializedObject` die 
"Deferred"-Meldungen mit `info` statt `debug` zu machen. 
Und den Test in :term:`initdb` entschärfe ich dann: er braucht 
nicht auf DEBUG zu stehen, wohl aber auf INFO.


  201103-03 10:51:13 DEBUG dpy : Deferred PropType #1 (Bewertung) : 
  {'choicelist': [u"Value u'HowWellDoYouKnow' is not a valid choice."]}

Also noch folgende Änderung in der .dpy-Datei::

  def create_properties_proptype(id,name,choicelist,limit_to_choices,multiple_choices,name_fr):
      if choicelist == 'HowWellDoYouKnow':
          choicelist = 'HowWell'
      return PropType(id=id,name=name,choicelist=choicelist,limit_to_choices=limit_to_choices,multiple_choices=
    
