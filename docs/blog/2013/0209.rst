20130209
========


Webless Lino
------------

Continued to work on the "Webless Lino" project.

This is for those who want to use Lino's Python fixtures
(:mod:`lino.utils.dumpy`)
and application startup signals 
(:mod:`lino.core.signals`) 
in an existing Django project without any change 
to their existing web interface (templates and urlconfs).

:srcref:`lino\apps\polls_tutorial_noweb`
is a "plain" Lino application without :mod:`lino.web`
which starts after the Django polls tutorial series,
adding only a few minor things:

(1) In :srcref:`settings.py <lino/apps/polls_tutorial_noweb/mysite/settings.py>`,
a line at the beginning of the file to instantiate our :setting:`LINO`::
::

    import lino; LINO = lino.Lino(__file__,globals()) 
    
Then we remove the 'django.contrib.sites' entry 
and add a "lino" entry to :setting:`INSTALLED_APPS`::

  INSTALLED_APPS = (
      ...
      # 'django.contrib.sites',
      ...
      'lino',
  )
  
And finally declare a local fixture directory::

  FIXTURE_DIRS = ['fixtures']


(2) A file 
:srcref:`polls/fixtures/demo.py
<lino/apps/polls_tutorial_noweb/polls/fixtures/demo.py>`,
a simple example of an "intelligent" Python fixture providing 
demo data for our application.

You can now reset your database to factory defaults by issuing::

  python manage.py initdb demo
  
You can make a complete python backup like this::
  
  python manage.py dumpdata > fixtures/a.py
  
And restore it like this::

  python manage.py initdb --dumped a
  


Note the difference between "intelligent" and "dumped"
fixtures:

- intelligent (written by a human):
  :srcref:`polls/fixtures/demo.py
  <lino/apps/polls_tutorial_noweb/polls/fixtures/demo.py>`

- dumped (generated by the dumpdata command):
  :srcref:`fixtures/a.py
  <lino/apps/polls_tutorial_noweb/fixtures/a.py>`,
  

The following problem took me some time.
Restoring the dumped fixture in our example failed with::

  WARNING Abandoning with 24 unsaved instances from fixtures\a.py:
  - auth.Permission {'id': [u'Permission with this ID already exists.'], '__all__':    [u'Permission with this Content type and Codename already exists.']} (24 object(s) with primary key 16, 17, 18, 1, 4, 7, 2, 5, 8, 3, 6, 9, 10, 11, 12, 19, 21, 23, 20, 22, 24, 13, 14, 15)

That's because these permission instances are being 
automatically created by 
`django.contrib.auth.management.create_permissions`
before the dumpy deserializer could restore them.
`create_permissions` is being invoked by the `post_sync` signal.
The problem is that `initdb` should not emit this `post_sync` 
signal at all.

I didn't find a less cruel method to solve this than amputating 
Django's `post_syncdb` signal::

    class NullSignal:
        def connect(*args,**kw):
            pass
        def send(*args,**kw):
            pass
    
    models.signals.post_syncdb = NullSignal()

This is done by the new `--dumped` option of loaddata.