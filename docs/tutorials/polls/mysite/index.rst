.. _lino.tutorial.polls:

The Lino Polls tutorial 
=======================

In this tutorial we are going to take the "Polls" 
application from Django's excellent tutorial and turn it 
into a Lino application.

The result of this tutorial is available as a public 
live demo at http://demo1.lino-framework.org

You might compare this with :ref:`north.tutorial.polls`.

.. contents:: Table of Contents
 :local:
 :depth: 2


Create a local Django project
-----------------------------

Before reading on, please follow
`Part 1 of the Django tutorial
<https://docs.djangoproject.com/en/1.4/intro/tutorial01/>`_,
which applies entirely for a Lino application.
Afterwards we meet here again. See you later!

Done? Okay, let's go further.
You have now a set of files in your "project directory". 
Your project is still lacking the most visible part:
a web interface.

The Django tutorial continues by introducing 
Django's Admin module to create a web interface.
We now leave the Django philosophy and continue 
"the Lino way" of defining our application's web interface.
Lino is an alternative to Django's Admin module.

Most files remain unchanged, they are the same as with every Django project:
:file:`__init__.py`, :file:`manage.py`,
:file:`urls.py` and :file:`wsgi.py`.
You might want to compare your files with our version 
which you can see in the code repository at
:srcref:`/lino/projects/polls_tutorial`.

But we are now going to modify the files 
:file:`settings.py` and
:file:`polls/models.py`.

The :file:`settings.py` file
-----------------------------

Lino uses some tricks to make Django :file:`settings.py`
files more pleasant to work with,
especially if you maintain Lino sites for several customers.

- Change the contents of your :file:`settings.py` 
  to the following:

.. literalinclude:: settings.py

A few explanations:

This instantiates your local ``SITE`` setting.
Every Lino application requires a setting named ``SITE`` 
which must be a :class:`lino.ui.Site` instance.

The first argument of the instantiator is the built-in 
Python variable `__file__`.
This is how Lino knows the full path of your local settings file.
  
The second argument is the `global()` namespace of your settings module.
Lino uses this to fill "intelligent default values" to your settings.
That's why these lines should be at the *beginning* of your file.

All remaining positional arguments will go into the :setting:`INSTALLED_APPS` setting.
In our example we have only one positional argument ``'polls'``.

Lino automatically adds some more apps before and after your app
As an application developer you don't need to worry about those 
additional "system" apps. 
Just trust Lino that he will fill into :setting:`INSTALLED_APPS` what is needed. 
Trust is good, control is better, so let's 
be curious and have a look at them:

Open a Django shell in your project directory::

  $ python manage.py shell
  
And then enter the following Python instructions there:  

>>> from django.conf import settings
>>> settings.INSTALLED_APPS
('lino.modlib.about', 'polls', 'lino', 'djangosite')

This shows that your 'polls' app has been embedded into a series of other apps:
:mod:`lino.ui` and :mod:`lino.modlib.about` come first, then your app, 
followed by :mod:`lino` and :mod:`djangosite`.

Other Django setting for which Lino sets default values are:

- :setting:`DATABASES` : a SQLite database in a file :file:`default.db` 
  in your project directory. On a production server you are of course going 
  to set your own :setting:`DATABASES`, but this default value is what we 
  think the best choice for beginners.
  
- :setting:`SER` : a file :file:`default.db` in your project directory.

- :setting:`USE_L10N` and  :setting:`LANGUAGE_CODE` : see :attr:``




>>> settings.SITE.title
'Cool Polls'


But with the difference that Lino automatically adds 
certain system modules when needed.
 
Some more Django settings deserve at least a comment:

- More documentation about the :setting:`LOGGING` 
  setting in :func:`lino.utils.log.configure`
  
- The :setting:`ROOT_URL` setting 
  and the files :file:`urls.py` and :file:`polls/views.py` 
  generated by Django
  are not necessary in our first Lino application. 
  With Lino you don't need to worry about URLs and views 
  because Lino defines them for you.



The :xfile:`models.py` file
---------------------------

- Change the contents of your :xfile:`polls/models.py` 
  to the following:

.. literalinclude:: ../polls/models.py

A few explanations while looking at that file:

- The :mod:`lino.dd` module is a shortcut to most Lino extensions 
  used by application programmers in their `models.py` modules. 
  `dd` stands for "data definition".
  
- :class:`dd.Model <lino.core.model.Model>` 
  is a thin and optional wrapper around Django's Model class.
  For this tutorial you could use Django's `models.Model` as well,
  but we recommend to use `dd.Model` when there's no doubt that 
  you want Lino and not only Django.

- :class:`dd.Table <lino.core.table.Table>` is used as base class 
  for the three **Table** definitions in our application.
  That's an important new concept in Lino, and
  we'll talk about it in the Tables_ section.

- There's one **custom action** in our application, 
  defined as the `vote` method on the `Choice` model, 
  using the :class:`dd.action <lino.core.actions.action>` 
  decorator. Another important new concept in Lino, 
  we'll talk about it in the Actions_ section.
  
  
The main index
--------------
  
The following template is used to 
build the HTML to be displayed in our Main Window. 

.. literalinclude:: config/admin_main.html

Explanations:

- ``<div class="htmlText">`` specifies that this fragment 
  contains simple html text inside an ExtJS component. 
  This is required because ExtJS does a lot of CSS magic which 
  neutralizes the "usual" effects of most html tags.

    
- ``site.modules`` : Every Lino site has an instance attribute ``modules``
  which is a shortcut to access the models and tables of the application.
  Usually it is better to write
  
  ::

    Poll = site.modules.polls.Poll

  instead of
  
  ::

    from site.modules.polls.models import Poll
  
  because the latter hard-wires the location of the `polls` app.
    
- If `objects`, `filter()` and `order_by()` are new to you, 
  then please read the `Making queries 
  <https://docs.djangoproject.com/en/dev/topics/db/queries>`_
  chapter of Django's documentation. 
  Lino is based on Django, and Django is known for its good documentation. Use it!

- If `joiner` and `sep` are a riddle to you, you'll find the 
  solution in Jinja's `Template Designer 
  Documentation <http://jinja.pocoo.org/docs/templates/#joiner>`__.
  Lino applications by default replace Django's template engine by Jinja.

- ``obj.vote`` is an :class:`InstanceAction <lino.core.actions.InstanceAction>`,
  and we call its 
  :meth:`as_button <lino.core.actions.InstanceAction.as_button>`
  method
  which returns a HTML fragment that displays a button-like 
  link which will run the action when clicked.
  More about this in Actions_.



Adding a demo fixture
---------------------

One more thing before seeing a result. 
We made at least one database change after the Django tutorial: 
we added the `hidden` field of a Poll.
So we must rebuild our database.
While we are there we'll also quickly add a demo fixture...
because that's so easy.

- Download the file   
  :srcref:`polls/fixtures/demo.py </docs/tutorials/polls/fixtures/demo.py>`  
  from the Lino repository and add it to a :file:`fixtures` directory
  below your project directory.
  
- Create an empty file :xfile:`__init__.py` in that same directory.
  
- Run the following command (from your project directory) 
  to install these fixtures::

    python manange.py initdb demo
    
  The output should be similar to::
  
    INFO Analyzing models...
    We are going to flush your database (C:\mysite\test.db).
    Are you sure (y/n) ?y
    INFO Lino initdb ('demo',) started on database C:\mysite\test.db.
    INFO Using Lino 1.4.9, Django 1.5.dev17937, python-dateutil 1.5, Cheetah 2.4.4, 
    OdfPy ODFPY/0.9.4, docutils 0.7, suds 0.4.1, PyYaml 3.08, Appy 0.8.0 (2011/12/15 22:41), 
    Python 2.7.1.
    Creating tables ...
    Creating table lino_siteconfig
    Creating table polls_poll
    Creating table polls_choice
    Installing custom SQL ...
    Installing indexes ...
    Installed 0 object(s) from 0 fixture(s)
    INFO Saved 13 instances from C:\mysite\polls\fixtures\demo.py.
    Installed 13 object(s) from 1 fixture(s)
    INFO Lino initdb done ('demo',) on database C:\mysite\polls\test.db.  
    
- Read more about :doc:`/tutorials/dumpy` 
  if you haven't done that yet.
  
Now we are ready to start the development web server on our project.
  
Starting the web interface
--------------------------

Start the development server::

  $ cd ~/mypy/mysite
  $ python manage.py runserver
  
or (on Windows)::

  c:\mypy\mysite> python manage.py runserver
  
and point your browser to http://127.0.0.1:8000/ 
to see your first Lino application running.

- Please play around and create some polls before reading on.


Screenshots
-----------

Make sure that you understand and can reproduce 
the concepts explained in this section.


The **Main Window** is the top-level window of your application:

.. image:: polls1.jpg
    :scale: 50
    
Your application specifies what to put there, and there are several 
methods to do this.
If you don't want to use an `admin_main.html` template
you may override the
:meth:`get_main_html <lino.Site.get_main_html>` method 
which returns a chunk of generated html.
    
After clicking on a vote, here is the `vote` method 
of our `Choice` model in action:

.. image:: polls2.jpg
    :scale: 50
    
    
After selecting :menuselection:`Polls --> Polls` in the main menu, 
Lino opens that table in a **Grid Window**:
    
.. image:: polls3.jpg
    :scale: 50
    
Every table can be displayed in a **Grid Window**, a tabular 
representation with common functionality such as sorting, 
setting column filters, editing individual cells, 
and a context menu.
  
After double-clicking on a row in the previous screen, Lino shows 
the **Detail Window** on that Poll:

.. image:: polls4.jpg
    :scale: 50
    
This window has been designed by the following code in 
your :file:`models.py` file::

    detail_layout = """
    id question 
    hidden pub_date
    ChoicesByPoll
    """

To add a Detail Window to a table, you simply add a 
:attr:`detail_layout 
<lino.core.actors.Actor.detail_layout>` attribute to the Table's 
class. 
See :doc:`/tutorials/layouts` for more explanations.
   
    
Not all tables have a Detail Window. 
In our case the `Polls` table has one, 
but the `Choices` and `ChoicesByPoll` tables don't.
Double-clicking on a cell of a Poll will open the Detail Window,
but double-clicking on a cell of a Choice will start cell editing.
Note that can still edit an individual cell of a Poll in a Grid Window 
by pressing the :kbd:`F2` key.
  
    
After clicking the :guilabel:`New` button, you can admire 
an **Insert Window**:

.. image:: polls5.jpg
    :scale: 50
    
This one exists because Polls has the following 
`insert_layout` attribute:: 

    insert_layout = dd.FormLayout("""
    question
    hidden
    """,window_size=(40,'auto'))
    
(Again: see :doc:`/tutorials/layouts` for more explanations.)

After clicking the :guilabel:`[html]` button:

.. image:: polls6.jpg
    :scale: 50
    
The :guilabel:`[pdf]` button works only if you have 
an OpenOffice or LibreOffice server running in 
background (don't worry about that for the moment).
    
.. image:: polls7.jpg
    :scale: 50


Tables
------

A Table is the "abstract" definition of a tabular view.
It is not only used for the Grid Window but also to implement 
the :guilabel:`[html]` and :guilabel:`[pdf]` views.

A Table definition has attributes
like `filter` and `sort_order` 
which you know from Django's QuerySet.

But it also has Lino-specific attributes like 
:attr:`column_names <lino.utils.tables.AbstractTable.column_names>`,
:attr:`detail_layout <lino.core.actors.Actor.detail_layout>` 
or
:attr:`parameters <lino.core.actors.Actor.parameters>`.

To define Tables, you simply need to declare their classes.
Tables never get instantiated.
Lino discovers and analyzes them when it initializes.

Each Table class must have at least one class attribute 
`model` defined. This points to the Model on which this 
table will "work".

There are a lot of other options for tables, 
and a consistent overview has yet to be written.
But you can try to work through the API docs, 
knowing that
:class:`lino.core.table.Table` 
inherits from
:class:`lino.utils.tables.AbstractTable` 
who inherits from
:class:`lino.core.actors.Actor`.

Since tables are normal Python classes 
they can use inheritance.
In our code `ChoicesByPoll` inherits from `Choices`. 
That's why we don't need to explicitly specify 
a `model` attribute for `ChoicesByPoll`.

`ChoicesByPoll` is an example of a **slave table**.
`ChoicesByPoll` means: the table of `Choices` of a given `Poll`. 
This given Poll is called the "master" of these Choices.
We also say that a slave table *depends* on its master.
Lino manages this dependency almost automatically.
The application developer just needs to specify a 
class attribute 
:attr:`master_key <lino.core.table.Table.master_key>`.
This is attribute, when set, must be a string containing 
the name of a `ForeignKey` field which 
must exist in the Table's model.


Note that you can define more than one Table per Model.
This is a fundamental difference from Django's concept of 
the `ModelAdmin` class and `Model._meta` options.


Actions
-------



Lino has a class :class:`Action <lino.core.actions.Action>` 
which represents the methods who have a clickable button 
or menu item in the user interface. 
Each :class:`Action <lino.core.actions.Action>`
instance holds a few important pieces of information:

- label : the text to place on the button or menu item
- help_text : the text to appear as tooltip when the mouse is over that button
- permission requirements : specify who and under which conditions this action is available (a complex subject, we'll talk about it in a later tutorial)
- handler function : the function to execute when the action is invoked

Many actions are created automatically by Lino. For example:

- each table has a "default action" which is 
  to open a window which displays this table as a grid.
  That's why (in the :meth:`setup_menu <lino.Lino.setup_menu>`
  method of your :xfile:`settings.py`) you can say::

    m.add_action(self.modules.polls.Polls)

  The :meth:`add_action <lino.core.menus.Menu.add_action>` method of Lino's 
  :class:`lino.core.menus.Menu` is smart enough to understand that if you 
  specify a Table, you mean in fact that table's default action.

- The :guilabel:`Save`, :guilabel:`Delete` and :guilabel:`New` 
  buttons in the bottom toolbar of the Detail window have their own 
  :class:`Action <lino.core.actions.Action>` instance.
  
Custom actions are the actions defined by the application developer.
Our tutorial has one of them:

.. code-block:: python
  
    @dd.action(help_text="Click here to vote this.")
    def vote(self,ar):
        def yes():
            self.votes += 1
            self.save()
            return ar.success(
                "Thank you for voting %s" % self,
                "Voted!",refresh=True)
        if self.votes > 0:
            msg = "%s has already %d votes!" % (self,self.votes)
            msg += "\nDo you still want to vote for it?"
            return ar.confirm(yes,msg)
        return yes()
    

The :func:`@dd.action <lino.core.actions.action>` decorator
can have keyword parameters to specify 
information about the action. In practice these may be 
:attr:`label <lino.core.actions.Action.label>`,
:attr:`help_text <lino.core.actions.Action.help_text>` and
:attr:`required <lino.core.actions.Action.required>`.

The action method itself should have the following signature::

    def vote(self,ar,**kw):
        ...
        return ar.success(kw)
        
Where `ar` is an :class:`ActionRequest <lino.core.actions.ActionRequest>` 
instance that holds information about the web request and provides methods 
like

- :meth:`callback <lino.ui.base.UI.callback>` 
  and :meth:`confirm <lino.ui.base.UI.confirm>`
  lets you define a dialog with the user using callbacks.

- :meth:`success <lino.ui.base.UI.success>` and
  :meth:`error <lino.ui.base.UI.error>` are possible return values
  where you can ask the client to do certain things.



Summary
-------

In this tutorial we followed Part 1 of the Django Tutorial, 
then continued the Lino way and explained two important new Lino concepts: 
Tables and Actions


